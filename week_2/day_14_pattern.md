ðŸ§  Pattern: In-Place Hashing (Index-as-Key)You used this pattern in First Missing Positive to bypass the $O(N)$ space limitation of standard Hash Maps.1. The Thought Process & Mindset (Constraint-Driven Design)When a problem asks for information about the presence of a set of integers (e.g., "which numbers are missing?") AND imposes an $O(1)$ space constraint, you must use the input array itself as the Hash Map.The Constraint: We only care about positive numbers in the range $[1, N]$.The Key-Value Mapping: We map the Value $x$ to the Index $x-1$.The Goal: Put the number $x$ into the index $x-1$ by swapping.2. The Implementation Technique (Swap Logic)The key challenge is the index control during the swapping phase:When to Swap: Only swap a number $x$ if it's relevant ($1 \le x \le N$) and if it's currently at the wrong index (i.e., $x \neq \text{nums}[x-1]$).Loop Control: After a successful swap, the index variable (i) must not increment. The newly swapped-in number at nums[i] must be checked immediately to see if it belongs at the current index, or if it needs to be swapped again. This ensures all relevant numbers are placed in $O(N)$ amortized time.3. The VerificationOnce the array is "hashed," the solution is simple: iterate from $i=0$ to $N-1$. The first index i where $\text{nums}[i] \neq i+1$ gives you the smallest missing positive integer $i+1$. If the entire array is sorted (i.e., $1, 2, \dots, N$), the answer is $N+1$.