## üìä **Google-Specific Problem Distribution**

- **Total Problems:** ~300 problems across 16 weeks
- **Google Priority:** High-frequency Google interview questions
- **Difficulty Focus:** 25% Easy, 65% Medium, 10% Hard
- **Daily Target:** 2-4 problems with emphasis on optimization

## üèóÔ∏è **Phase 1: Google Core Fundamentals** _(Weeks 1-4)_

### **Week 1: Arrays & String Processing**

_Google's bread and butter - search, parsing, optimization_

#### **üü¢ Google Easy Essentials**

- [ ] **1. Two Sum** _(Classic hash map - asked in 90% of Google phone screens)_
- [ ] **20. Valid Parentheses** _(Stack fundamentals)_
- [ ] **121. Best Time to Buy and Sell Stock** _(Single pass optimization)_
- [ ] **125. Valid Palindrome** _(String processing)_
- [ ] **167. Two Sum II** _(Two pointers on sorted array)_
- [ ] **242. Valid Anagram** _(String frequency analysis)_
- [ ] **344. Reverse String** _(In-place manipulation)_
- [ ] **387. First Unique Character in a String** _(Hash map frequency)_

#### **üü° Google Medium Favorites**

- [ ] **3. Longest Substring Without Repeating Characters** _(Sliding window classic)_
- [ ] **5. Longest Palindromic Substring** _(String DP/expand around center)_
- [ ] **11. Container With Most Water** _(Two pointers optimization)_
- [ ] **15. 3Sum** _(Two pointers + sorting)_
- [ ] **49. Group Anagrams** _(Hash map + string sorting)_
- [ ] **56. Merge Intervals** _(Sorting + merging logic)_
- [ ] **238. Product of Array Except Self** _(Prefix/suffix optimization)_
- [ ] **271. Encode and Decode Strings** _(String encoding design)_
- [ ] **424. Longest Repeating Character Replacement** _(Advanced sliding window)_

#### **üî¥ Google Hard Challenges**

- [ ] **76. Minimum Window Substring** _(Complex sliding window - very frequent)_

---

### **Week 2: Hash Tables & Advanced Data Structures**

_Google loves efficient lookups and cache design_

#### **üü¢ Google Easy Building Blocks**

- [ ] **13. Roman to Integer** _(Hash map lookup patterns)_
- [ ] **169. Majority Element** _(Boyer-Moore algorithm)_
- [ ] **217. Contains Duplicate** _(Hash set basics)_
- [ ] **268. Missing Number** _(Multiple approaches comparison)_
- [ ] **349. Intersection of Two Arrays** _(Set operations)_
- [ ] **383. Ransom Note** _(Frequency counting)_

#### **üü° Google Medium Core**

- [ ] **36. Valid Sudoku** _(Hash set validation)_
- [ ] **128. Longest Consecutive Sequence** _(Hash set + sequence finding)_
- [ ] **146. LRU Cache** _(Google's #1 design problem - absolutely crucial)_
- [ ] **347. Top K Frequent Elements** _(Heap + hash map)_
- [ ] **380. Insert Delete GetRandom O(1)** _(Advanced design problem)_
- [ ] **454. 4Sum II** _(Hash map optimization)_
- [ ] **560. Subarray Sum Equals K** _(Prefix sum + hash map)_

#### **üî¥ Google Hard Must-Know**

- [ ] **41. First Missing Positive** _(In-place hash set)_
- [ ] **460. LFU Cache** _(Complex design problem)_

---

### **Week 3: Linked Lists & Pointers**

_Google tests pointer manipulation and edge case handling_

#### **üü¢ Google Easy Fundamentals**

- [ ] **21. Merge Two Sorted Lists** _(Basic merging)_
- [ ] **83. Remove Duplicates from Sorted List** _(Single pass)_
- [ ] **141. Linked List Cycle** _(Floyd's cycle detection)_
- [ ] **160. Intersection of Two Linked Lists** _(Two pointers)_
- [ ] **203. Remove Linked List Elements** _(Dummy node technique)_
- [ ] **206. Reverse Linked List** _(Iterative and recursive)_
- [ ] **234. Palindrome Linked List** _(Multiple techniques)_

#### **üü° Google Medium Essentials**

- [ ] **2. Add Two Numbers** _(Digit-by-digit processing)_
- [ ] **19. Remove Nth Node From End** _(Two pointers)_
- [ ] **24. Swap Nodes in Pairs** _(Node manipulation)_
- [ ] **61. Rotate List** _(Cycle creation)_
- [ ] **92. Reverse Linked List II** _(Partial reversal)_
- [ ] **138. Copy List with Random Pointer** _(Deep copy with random pointers)_
- [ ] **142. Linked List Cycle II** _(Cycle detection + location)_
- [ ] **143. Reorder List** _(Multiple pointer techniques)_

#### **üî¥ Google Hard Classics**

- [ ] **23. Merge k Sorted Lists** _(Divide and conquer + heap)_
- [ ] **25. Reverse Nodes in k-Group** _(Advanced pointer manipulation)_

---

### **Week 4: Stacks, Queues & Monotonic Structures**

_Google frequently tests stack-based algorithms_

#### **üü¢ Google Easy Stack Basics**

- [ ] **155. Min Stack** _(Design with O(1) operations)_
- [ ] **225. Implement Stack using Queues** _(Design conversion)_
- [ ] **232. Implement Queue using Stacks** _(Design conversion)_
- [ ] **844. Backspace String Compare** _(Stack simulation)_

#### **üü° Google Medium Stack Masters**

- [ ] **22. Generate Parentheses** _(Backtracking + stack)_
- [ ] **71. Simplify Path** _(Stack + string parsing)_
- [ ] **150. Evaluate Reverse Polish Notation** _(Stack evaluation)_
- [ ] **394. Decode String** _(Nested stack processing)_
- [ ] **496. Next Greater Element I** _(Monotonic stack intro)_
- [ ] **503. Next Greater Element II** _(Circular monotonic stack)_
- [ ] **739. Daily Temperatures** _(Monotonic stack classic)_

#### **üî¥ Google Hard Stack Experts**

- [ ] **84. Largest Rectangle in Histogram** _(Monotonic stack mastery)_
- [ ] **85. Maximal Rectangle** _(2D histogram problem)_

---

## üöÄ **Phase 2: Google Algorithm Specialties** _(Weeks 5-8)_

### **Week 5: Binary Trees**

_Google's favorite data structure for hierarchical problems_

#### **üü¢ Google Easy Tree Basics**

- [ ] **94. Binary Tree Inorder Traversal** _(Iterative and recursive)_
- [ ] **100. Same Tree** _(DFS comparison)_
- [ ] **101. Symmetric Tree** _(Mirror tree logic)_
- [ ] **104. Maximum Depth of Binary Tree** _(DFS/BFS depth)_
- [ ] **108. Convert Sorted Array to BST** _(Balanced tree construction)_
- [ ] **110. Balanced Binary Tree** _(Height-balanced validation)_
- [ ] **111. Minimum Depth of Binary Tree** _(BFS optimal)_
- [ ] **112. Path Sum** _(Root-to-leaf DFS)_

#### **üü° Google Medium Tree Mastery**

- [ ] **102. Binary Tree Level Order Traversal** _(BFS layer by layer)_
- [ ] **103. Binary Tree Zigzag Level Order** _(BFS with direction)_
- [ ] **105. Construct Binary Tree from Preorder/Inorder** _(Tree reconstruction)_
- [ ] **114. Flatten Binary Tree to Linked List** _(In-place transformation)_
- [ ] **116. Populating Next Right Pointers** _(Level connection)_
- [ ] **124. Binary Tree Maximum Path Sum** _(DFS with global max)_
- [ ] **199. Binary Tree Right Side View** _(BFS rightmost)_
- [ ] **236. Lowest Common Ancestor** _(DFS ancestor finding)_
- [ ] **297. Serialize and Deserialize Binary Tree** _(Tree encoding/decoding)_

#### **üî¥ Google Hard Tree Challenges**

- [ ] **99. Recover Binary Search Tree** _(Inorder traversal + swap)_
- [ ] **145. Binary Tree Postorder Traversal** _(Iterative postorder)_

---

### **Week 6: Binary Search Trees & Search Algorithms**

_Google emphasizes search optimization and BST properties_

#### **üü¢ Google Easy BST Fundamentals**

- [ ] **98. Validate Binary Search Tree** _(BST property validation)_
- [ ] **235. LCA of BST** _(BST-specific LCA)_
- [ ] **270. Closest BST Value** _(BST search)_
- [ ] **530. Minimum Absolute Difference in BST** _(Inorder property)_
- [ ] **653. Two Sum IV - Input is BST** _(BST + hash set)_
- [ ] **700. Search in BST** _(Basic BST search)_

#### **üü° Google Medium BST Applications**

- [ ] **96. Unique Binary Search Trees** _(Catalan numbers DP)_
- [ ] **173. BST Iterator** _(Design + controlled traversal)_
- [ ] **230. Kth Smallest Element in BST** _(Inorder traversal)_
- [ ] **285. Inorder Successor in BST** _(BST navigation)_
- [ ] **450. Delete Node in BST** _(BST modification)_
- [ ] **701. Insert into BST** _(BST insertion)_

#### **üü° Google Binary Search Classics**

- [ ] **33. Search in Rotated Sorted Array** _(Modified binary search)_
- [ ] **34. Find First and Last Position** _(Binary search bounds)_
- [ ] **35. Search Insert Position** _(Basic binary search)_
- [ ] **69. Sqrt(x)** _(Binary search on answer)_
- [ ] **74. Search 2D Matrix** _(2D binary search)_
- [ ] **153. Find Minimum in Rotated Array** _(Rotation point)_
- [ ] **162. Find Peak Element** _(Binary search on unsorted)_
- [ ] **278. First Bad Version** _(Binary search template)_
- [ ] **300. Longest Increasing Subsequence** _(Binary search + DP)_

#### **üî¥ Google Hard Search**

- [ ] **4. Median of Two Sorted Arrays** _(Advanced binary search)_

---

### **Week 7: Graph Algorithms**

_Google loves graph problems for dependency and connectivity analysis_

#### **üü¢ Google Easy Graph Intro**

- [ ] **463. Island Perimeter** _(Grid boundary counting)_
- [ ] **733. Flood Fill** _(DFS/BFS basics)_
- [ ] **997. Find the Town Judge** _(Graph theory basics)_

#### **üü° Google Medium Graph Core**

- [ ] **133. Clone Graph** _(DFS/BFS + hash map)_
- [ ] **200. Number of Islands** _(DFS/BFS grid traversal)_
- [ ] **207. Course Schedule** _(Topological sort + cycle detection)_
- [ ] **210. Course Schedule II** _(Topological sort ordering)_
- [ ] **261. Graph Valid Tree** _(Tree validation in graph)_
- [ ] **323. Number of Connected Components** _(Union-Find/DFS)_
- [ ] **417. Pacific Atlantic Water Flow** _(Multi-source DFS)_
- [ ] **547. Number of Provinces** _(Connected components)_
- [ ] **684. Redundant Connection** _(Union-Find cycle detection)_
- [ ] **695. Max Area of Island** _(DFS with area calculation)_
- [ ] **721. Accounts Merge** _(Union-Find + string processing)_
- [ ] **994. Rotting Oranges** _(Multi-source BFS)_

#### **üî¥ Google Hard Graph**

- [ ] **127. Word Ladder** _(BFS shortest path)_
- [ ] **269. Alien Dictionary** _(Topological sort on characters)_
- [ ] **305. Number of Islands II** _(Dynamic Union-Find)_

---

### **Week 8: Mathematical & Optimization Problems**

_Google tests analytical thinking and optimization skills_

#### **üü¢ Google Easy Math**

- [ ] **7. Reverse Integer** _(Integer manipulation + overflow)_
- [ ] **9. Palindrome Number** _(Number processing)_
- [ ] **66. Plus One** _(Array arithmetic)_
- [ ] **172. Factorial Trailing Zeroes** _(Mathematical insight)_
- [ ] **202. Happy Number** _(Cycle detection in math)_
- [ ] **231. Power of Two** _(Bit manipulation)_
- [ ] **326. Power of Three** _(Mathematical validation)_

#### **üü° Google Medium Math & Logic**

- [ ] **8. String to Integer (atoi)** _(Robust parsing)_
- [ ] **12. Integer to Roman** _(Number system conversion)_
- [ ] **43. Multiply Strings** _(Large number arithmetic)_
- [ ] **50. Pow(x, n)** _(Fast exponentiation)_
- [ ] **166. Fraction to Recurring Decimal** _(Mathematical conversion)_
- [ ] **171. Excel Sheet Column Number** _(Base conversion)_
- [ ] **204. Count Primes** _(Sieve of Eratosthenes)_
- [ ] **258. Add Digits** _(Digital root)_
- [ ] **264. Ugly Number II** _(Multiple pointer technique)_

#### **üî¥ Google Hard Math**

- [ ] **65. Valid Number** _(Complex string validation)_
- [ ] **224. Basic Calculator** _(Expression parsing)_

---

## üß† **Phase 3: Advanced Google Topics** _(Weeks 9-12)_

### **Week 9: Dynamic Programming Fundamentals**

_Google's optimization-focused DP problems_

#### **üü¢ Google Easy DP**

- [ ] **70. Climbing Stairs** _(Classic linear DP)_
- [ ] **118. Pascal's Triangle** _(2D DP pattern)_
- [ ] **119. Pascal's Triangle II** _(Space-optimized DP)_
- [ ] **198. House Robber** _(Linear DP with choice)_
- [ ] **746. Min Cost Climbing Stairs** _(DP with cost)_

#### **üü° Google Medium DP Core**

- [ ] **55. Jump Game** _(Greedy vs DP approaches)_
- [ ] **62. Unique Paths** _(2D grid DP)_
- [ ] **63. Unique Paths II** _(DP with obstacles)_
- [ ] **64. Minimum Path Sum** _(2D optimization DP)_
- [ ] **91. Decode Ways** _(String DP)_
- [ ] **139. Word Break** _(String + dictionary DP)_
- [ ] **152. Maximum Product Subarray** _(DP with positive/negative state)_
- [ ] **213. House Robber II** _(Circular array DP)_
- [ ] **279. Perfect Squares** _(Unbounded knapsack)_
- [ ] **300. Longest Increasing Subsequence** _(LIS optimization)_
- [ ] **322. Coin Change** _(Classic unbounded knapsack)_

#### **üî¥ Google Hard DP**

- [ ] **32. Longest Valid Parentheses** _(Complex string DP)_
- [ ] **72. Edit Distance** _(Classic 2D DP)_

---

### **Week 10: Advanced Dynamic Programming**

_Google's complex state management problems_

#### **üü° Google Medium Advanced DP**

- [ ] **5. Longest Palindromic Substring** _(2D DP vs expand around center)_
- [ ] **45. Jump Game II** _(DP vs greedy optimization)_
- [ ] **97. Interleaving String** _(3-string DP)_
- [ ] **115. Distinct Subsequences** _(2D counting DP)_
- [ ] **120. Triangle** _(Bottom-up DP)_
- [ ] **221. Maximal Square** _(2D DP with max area)_
- [ ] **309. Best Time to Buy and Sell Stock with Cooldown** _(State machine DP)_
- [ ] **377. Combination Sum IV** _(Counting DP)_
- [ ] **416. Partition Equal Subset Sum** _(0/1 knapsack)_
- [ ] **516. Longest Palindromic Subsequence** _(2D string DP)_

#### **üî¥ Google Hard Advanced DP**

- [ ] **10. Regular Expression Matching** _(2D pattern matching DP)_
- [ ] **44. Wildcard Matching** _(2D wildcard DP)_
- [ ] **87. Scramble String** _(3D recursive DP)_
- [ ] **312. Burst Balloons** _(Interval DP)_

---

### **Week 11: System Design & Advanced Data Structures**

_Google's scalability and design focus_

#### **üü° Google Medium Design Problems**

- [ ] **146. LRU Cache** _(Must master - most frequent Google design)_
- [ ] **155. Min Stack** _(O(1) operations design)_
- [ ] **173. BST Iterator** _(Iterator design pattern)_
- [ ] **208. Implement Trie** _(Prefix tree implementation)_
- [ ] **211. Design Add and Search Words Data Structure** _(Trie with wildcards)_
- [ ] **225. Implement Stack using Queues** _(Data structure conversion)_
- [ ] **232. Implement Queue using Stacks** _(Data structure conversion)_
- [ ] **284. Peeking Iterator** _(Iterator wrapper design)_
- [ ] **341. Flatten Nested List Iterator** _(Complex iterator design)_
- [ ] **380. Insert Delete GetRandom O(1)** _(Array + hash map design)_

#### **üî¥ Google Hard Design**

- [ ] **295. Find Median from Data Stream** _(Heap-based design)_
- [ ] **348. Design Tic-Tac-Toe** _(Game state optimization)_
- [ ] **460. LFU Cache** _(Complex caching policy)_

---

### **Week 12: Backtracking & Advanced Algorithms**

_Google's constraint satisfaction problems_

#### **üü° Google Medium Backtracking**

- [ ] **17. Letter Combinations of a Phone Number** _(Basic backtracking)_
- [ ] **22. Generate Parentheses** _(Constraint backtracking)_
- [ ] **39. Combination Sum** _(Backtracking with reuse)_
- [ ] **40. Combination Sum II** _(Backtracking with duplicates)_
- [ ] **46. Permutations** _(Basic permutation generation)_
- [ ] **47. Permutations II** _(Permutations with duplicates)_
- [ ] **78. Subsets** _(Subset generation)_
- [ ] **79. Word Search** _(2D grid backtracking)_
- [ ] **90. Subsets II** _(Subsets with duplicates)_
- [ ] **131. Palindrome Partitioning** _(String backtracking)_
- [ ] **212. Word Search II** _(Trie + backtracking)_

#### **üî¥ Google Hard Backtracking**

- [ ] **37. Sudoku Solver** _(Constraint satisfaction)_
- [ ] **51. N-Queens** _(Classic backtracking with constraints)_

---

## üéØ **Phase 4: Google Interview Simulation** _(Weeks 13-16)_

### **Week 13-14: Google's Most Frequent Interview Problems**

#### **üî• Google Top 20 Must-Solve** _(Asked in 70%+ of Google interviews)_

1. [ ] **üü° 146. LRU Cache** _(Design - 85% frequency)_
2. [ ] **üü° 200. Number of Islands** _(Graph - 75% frequency)_
3. [ ] **üü° 3. Longest Substring Without Repeating Characters** _(String - 70% frequency)_
4. [ ] **üî¥ 76. Minimum Window Substring** _(Sliding window - 65% frequency)_
5. [ ] **üü° 56. Merge Intervals** _(Arrays - 60% frequency)_
6. [ ] **üü° 139. Word Break** _(DP - 55% frequency)_
7. [ ] **üü° 15. 3Sum** _(Arrays - 55% frequency)_
8. [ ] **üü° 207. Course Schedule** _(Graph - 50% frequency)_
9. [ ] **üü° 297. Serialize and Deserialize Binary Tree** _(Tree - 50% frequency)_
10. [ ] **üü° 208. Implement Trie** _(Design - 45% frequency)_
11. [ ] **üü° 124. Binary Tree Maximum Path Sum** _(Tree - 45% frequency)_
12. [ ] **üü° 128. Longest Consecutive Sequence** _(Hash - 40% frequency)_
13. [ ] **üü° 33. Search in Rotated Sorted Array** _(Binary Search - 40% frequency)_
14. [ ] **üü° 49. Group Anagrams** _(String - 40% frequency)_
15. [ ] **üü° 102. Binary Tree Level Order Traversal** _(Tree - 35% frequency)_
16. [ ] **üü° 322. Coin Change** _(DP - 35% frequency)_
17. [ ] **üü° 133. Clone Graph** _(Graph - 35% frequency)_
18. [ ] **üü° 5. Longest Palindromic Substring** _(String - 30% frequency)_
19. [ ] **üü° 236. Lowest Common Ancestor of a Binary Tree** _(Tree - 30% frequency)_
20. [ ] **üü° 230. Kth Smallest Element in a BST** _(BST - 30% frequency)_

### **Week 15-16: Google System Design + Advanced Problems**

#### **üèóÔ∏è Google System Design Practice**

- [ ] **Design Google Search Engine** _(Web crawling + indexing)_
- [ ] **Design YouTube** _(Video storage + streaming)_
- [ ] **Design Google Drive** _(File storage + sync)_
- [ ] **Design Gmail** _(Email system + search)_
- [ ] **Design Google Maps** _(Geospatial + routing)_
- [ ] **Design URL Shortener** _(Hashing + caching)_
- [ ] **Design Chat System** _(Real-time messaging)_
- [ ] **Design News Feed** _(Social media feed)_

#### **üî¥ Google Final Challenge Problems**

- [ ] **42. Trapping Rain Water** _(Two pointers/stack)_
- [ ] **84. Largest Rectangle in Histogram** _(Monotonic stack)_
- [ ] **239. Sliding Window Maximum** _(Deque optimization)_
- [ ] **269. Alien Dictionary** _(Topological sort)_
- [ ] **295. Find Median from Data Stream** _(Heap design)_
- [ ] **336. Palindrome Pairs** _(Trie + string manipulation)_



