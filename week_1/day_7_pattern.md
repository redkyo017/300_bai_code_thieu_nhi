ðŸ§  Pattern: Hard Sliding Window (State-Based)You have successfully implemented the hardest version of the Sliding Window pattern. The key takeaway is how we integrate two patterns to achieve $O(N)$ time complexity.The Intuition: The "Satisfied Criteria" CounterIn simple sliding window problems (like "Longest Substring Without Repeating Characters"), the validation check is simple: Is the character already in the set?In hard problems like Minimum Window Substring, the validation check is complex: Are the frequency counts of all required characters in T met by the current window S?The solution is to use a matched counter to avoid an $O(N)$ check of the whole frequency map every time the window moves.The Three Pillars of Hard Sliding WindowPreparation (O(T)): Create the targetFreq (what you need).Expansion (O(N)): The right pointer moves forward, expanding the window. The matched counter is incremented only when a required character's count reaches its target value.Contraction (O(1) Check): Once matched == required, the window is valid. The left pointer moves forward, shrinking the window. The matched counter is decremented only when a required character's count drops below its target value, which invalidates the window and stops the contraction.This state tracking ensures you only perform $O(1)$ operations per character in both the expansion and contraction phases, leading to an optimal $O(N)$ Time Complexity.